#Task 1
#School

#Make a class structure in python representing people at school. Make a base class called Person, a class called Student,
#and another one called Teacher.
#Try to find as many methods and attributes as you can which belong to different classes,
#and keep in mind which are common and which are not.
#For example, the name should be a Person attribute, while salary should only be available to the teacher. 

class Person:
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender
        
    def talk(self):
        print(f"Hello! My name is {self.name}. I'm {self.age} years old and I identify as {self.gender}.")
        
class Student(Person):
    def __init__(self, name, age, gender, grades):
        super().__init__(name, age, gender) #take from main commom Person
        self.grades = grades #grades are for students
        self.studyprograms = []
        self.menteeprograms = []
        self.sportsteams = []
        
    def add_program(self, program): #method add_programs is for Students 
        self.studyprograms.append(program)
        print(f"{self.name} has enrolled into {program} class.")

    def add_menteeprogram(self,menteeprogram):
        self.menteeprograms.append(menteeprogram)
        print(f"{self.name} added {menteeprogram} to their schedule.")

    def add_sportsteam(self,sportsteam):
        self.sportsteams.append(sportsteam)
        print(f"{self.name} joined team {sportsteam} as extra curriculum activity.")
        
    def list_programs(self):
        print(f"{self.name}'s programs: {', '.join(self.studyprograms)}")
        
class Teacher(Person):
    def __init__(self, name, age, gender, subject, salary):
        super().__init__(name, age, gender) #common to all, taken from main class Person
        self.subject = subject
        self.salary = salary
        self.courses_mentored = [] 
        
    def add_course_mentored(self,course):
        self.courses_mentored.append(course)
        print(f"{self.name} will become a mentor of the {course}.")
        
    def list_courses_mentored(self):
        print(f"Courses mentored by {self.name}: {', '.join(self.courses_mentored)}")

person1 = Person("Isabella", 35, "female")
person1.talk()

student1 = Student("Anna", 16, "female", 10) #name age gender, grades 
student1.talk()
student1.add_program("Philosophy")
student1.add_menteeprogram("Rhetoric")
student1.add_sportsteam("Bengals")                    
student1.list_programs()

teacher1 = Teacher("Lilian", 45, "female", "Math", 50000)
teacher1.talk()
teacher1.add_course_mentored("Computer Science")
teacher1.add_course_mentored("Geometry")
teacher1.list_courses_mentored()

#вивiд 
#Hello! My name is Isabella. I'm 35 years old and I identify as female.
#Hello! My name is Anna. I'm 16 years old and I identify as female.
#Anna has enrolled into Philosophy class.
#Anna added Rhetoric to their schedule.
#Anna joined team Bengals as extra curriculum activity.
#Anna's programs: Philosophy
#Hello! My name is Lilian. I'm 45 years old and I identify as female.
#Lilian will become a mentor of the Computer Science.
#Lilian will become a mentor of the Geometry.
#Courses mentored by Lilian: Computer Science, Geometry



#Task2
#Mathematician
#Implement a class Mathematician which is a helper class for doing math operations on lists
#The class doesn't take any attributes and only has methods:

#square_nums (takes a list of integers and returns the list of squares)
#remove_positives (takes a list of integers and returns it without positive numbers
#filter_leaps (takes a list of dates (integers) and removes those that are not 'leap years'



class Mathematician:
    
    @staticmethod
    def square_nums(nums):
        """Returns list of squares of the numbers in the input list of integers."""
        return [n ** 2 for n in nums]
    
    @staticmethod
    def remove_positives(nums):
        """Returns a list of the input numbers without the positive ones."""
        return [n for n in nums if n <= 0]
    
    @staticmethod
    def remove_nonleaps(dates):
        """Returns a list of the input dates that are leap years."""
        return [year for year in dates if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0]

m = Mathematician()

assert m.square_nums([7, 11, 5, 4]) == [49, 121, 25, 16]

assert m.remove_positives([26, -11, -8, 13, -90]) == [-11, -8, -90]

assert m.remove_nonleaps([2001, 1884, 1995, 2003, 2020]) == [1884, 2020]

print(m.square_nums([7, 11, 5, 4]))
print(m.remove_positives([26, -11, -8, 13, -90]))
print(m.remove_nonleaps([2001, 1884, 1995, 2003, 2020]))


